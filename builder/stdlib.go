package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"nix/derivation"
	"os"
	"path/filepath"
	"slices"
)

const (
	stdlibUsage = `
Usage: builder stdlib [subcommand]

Subcommands:
  list 
  package`
)

type StdlibPackage struct {
	ImportPath string

	// These are all omitempty to match the output of the Go compiler.

	GoFiles []string `json:",omitempty"`
	HFiles  []string `json:",omitempty"`
	SFiles  []string `json:",omitempty"`

	Imports   []string          `json:",omitempty"`
	ImportMap map[string]string `json:",omitempty"`

	EmbedPatterns []string `json:",omitempty"`
	EmbedFiles    []string `json:",omitempty"`
}

type PackageStdlibAttrs struct {
	Packages map[string]struct {
		Export string
		Lib    string
	}
	ImportMap map[string]string
}

// saveStdlibPackages parses the JSON package list generated by the Go, and
// writes the metadata for each package to the output directory.
func saveStdlibPackages(in io.Reader, path string) error {
	var pkgs []StdlibPackage

	decoder := json.NewDecoder(in)
	for decoder.More() {
		var pkg StdlibPackage
		if err := decoder.Decode(&pkg); err != nil {
			return err
		}

		// This should only be test-only packages.
		if pkg.GoFiles == nil {
			continue
		}

		modified := false
		for i := 0; i < len(pkg.Imports); i++ {
			if FilterInternalPackages(pkg.Imports[i]) {
				modified = true
				lastIdx := len(pkg.Imports) - 1
				pkg.Imports[i] = pkg.Imports[lastIdx]
				pkg.Imports = pkg.Imports[:lastIdx]
				i--
			}
		}
		if modified {
			slices.Sort(pkg.Imports)
		}

		if !FilterInternalPackages(pkg.ImportPath) {
			pkgs = append(pkgs, pkg)
		}
	}

	file, err := os.Create(filepath.Join(path, "spec.json"))
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	return encoder.Encode(&pkgs)
}

// listStdlib creates a JSON file defining every package in the standard
// library, so Nix can produce a build plan for it.
func listStdlib(sdk *GoSDK) {
	out := derivation.Outputs["out"]
	if out == "" {
		log.Fatalf("derivation was expected to produce an output \"out\"")
	}
	if err := os.Mkdir(out, 0755); err != nil {
		log.Fatalf("failed to create output directory: %v", err)
	}

	cmd := sdk.RunGo("list", "-json", "std")
	cmd.Stderr = os.Stderr
	cmd.Env = []string{
		"CGO_ENABLED=0",
		fmt.Sprintf("GOCACHE=%s/go-cache", os.TempDir()),
		fmt.Sprintf("GOROOT=%s", sdk.Path),
	}
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Fprintln(os.Stderr, cmd)
	if err := cmd.Start(); err != nil {
		log.Fatal(err)
	}
	if err := saveStdlibPackages(stdout, out); err != nil {
		log.Fatalf("failed to generate stdlib package list: %v", err)
	}

	if err := cmd.Wait(); err != nil {
		log.Fatal(err)
	}
}

// packageStdlib creates meta-package output which depends on every package
// in the standard library. Putting this as deps during compile will load the
// entire standard library into the workspace.
func packageStdlib() {
	attrs := derivation.GetAttrs[PackageStdlibAttrs]()

	libDir, err := OutputPath("lib")
	if err != nil {
		log.Fatal(err)
	}
	exportDir, err := OutputPath("export")
	if err != nil {
		log.Fatal(err)
	}

	subLibs := make([]Import, 0, len(attrs.Packages))
	subExports := make([]Import, 0, len(attrs.Packages))
	for importPath, storePaths := range attrs.Packages {
		subLibs = append(subLibs, Import{storePaths.Lib, importPath})
		subExports = append(subExports, Import{storePaths.Export, importPath})
	}
	SortImports(subLibs)
	SortImports(subExports)

	lib := MetaPackage{"std", subLibs, nil}
	if err := SaveMetadata(libDir, lib); err != nil {
		log.Fatalf("failed to generate stdlib package libs: %v", err)
	}
	export := MetaPackage{"std", subExports, attrs.ImportMap}
	if err := SaveMetadata(exportDir, export); err != nil {
		log.Fatalf("failed to generate stdlib package exports: %v", err)
	}
}

func stdlib(sdk *GoSDK) {
	subcommand := os.Args[2]
	switch subcommand {
	case "list":
		listStdlib(sdk)
	case "package":
		packageStdlib()
	default:
		log.Fatalf("unknown subcommand \"%s\"\n%s", subcommand, stdlibUsage)
	}
}
